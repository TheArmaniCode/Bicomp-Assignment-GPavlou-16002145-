import random
import csv

N = 80 #size of gene
P = 50 #size of population
G = 50 #number of generations

class individual:
    gene = None
    fitness = None

    def __init__(self, N):
        self.gene = []
        self.fitness = 0
        j = 0
        for i in range(N):
            # generate random float value
            numCondition = float(random.randrange(0, 10000))/10000
            numAction = random.randint(0,1)
            # append each value to gene
            if(i == j*8+7):
                self.gene.append(numAction)
                j += 1
            else:
                self.gene.append(numCondition)

#Do I need this class?
class offspr:
    gene = None
    fitness = None

    def __init__(self):
        self.gene = []
        self.fitness = 0

class rule:
    condition = None
    action = None

    def __init__(self):
        self.condition = []
        self.action = 0

population = []

for i in range(P):
    # for each method in population, append new individual
    population.append(individual(N))

def createRules(population, dataList):
    for i in population:
        rules = []
        for j in range(0, int(N/8)):
            # create instance of rule class
            r = rule()
            # declare rules and add to class
            for l in range(0,7):
                r.condition.append(i.gene[j*8+l])
            r.action = i.gene[j*8+7]
            #print(r.action)
            #append to rules array
            rules.append(r)
        match = 0
        for k in dataList:
            for l in rules:
                for m in range(0, 7):
                    #if match
                    if k[m] == l.condition[m]:
                        #increment match
                        match += 1
                    #if wildcard found,
                    elif l.condition[m] == 2:
                        #increment match
                        match += 1
                #if all 7 integers match
                if(match == 7):
                    #if action match
                    if k[7] == l.action:
                        #increment fitness of solution in population
                        i.fitness += 1
                    break
                match = 0

def selection(population, offspring):
    for i in range(P):
        #select two random variables for offspring
        parent1 = random.randint(0, P - 1)
        parent2 = random.randint(0, P - 1)
        #compare fitness in
        if population[parent1].fitness >= population[parent2].fitness:
            offspring.append(population[parent1])
        else:
            offspring.append(population[parent2])
    #print(len(offspring))

def crossover(parent1, parent2, crossoverOffspring):
    #generate random crossover point
    crossoverPoint = random.randint(0, N)
    child = []
    child2 = []
    for i in range(N):
        #if not past crossover point, add parent1 integers to gene, else add parent2 integers
        if i <= crossoverPoint:
            child.append(parent1.gene[i])
            child2.append(parent2.gene[i])
        else:
            child.append(parent2.gene[i])
            child2.append(parent1.gene[i])
    #Add to offspring once finished
    o = offspr()
    o2 = offspr()
    o.gene = child
    o2.gene = child2
    crossoverOffspring.append(o)
    crossoverOffspring.append(o2)

def mutation(parent, mutatedOffspring):
    mrate = 0.01
    child = []
    for i in parent:
        #generate random decimal
        r = float(random.randrange(0, 100))/100
        #if random decimal is less than or equal to mutation rate
        if r <= mrate:
            #flip values
            child.append(1-i)
        else:
            child.append(i)
    o = offspr()
    o.gene = child
    mutatedOffspring.append(o)

dataList = []

with open('data3.txt') as f:
    f.readline()
    f.readline()

    csv_reader = csv.reader(f, delimiter=' ')

    for i in csv_reader:
        l = []
        for j in range(8):
            if j == 7:
                f = int(i[j])
            else:
                f = float(i[j])
            l.append(f)
        dataList.append(l)

for i in range(G):
    #print offspring of current population BEFORE crossover and mutation
    createRules(population, dataList)# CORRECT
    offspring = []
    crossoverOffspring = []
    mutatedOffspring = []
    selection(population, offspring) #CORRECT
    for j in range(0, int(P/2)):
        crossover(offspring[j*2], offspring[j*2 + 1], crossoverOffspring) #CORRECT
    for j in crossoverOffspring:
        mutation(j.gene, mutatedOffspring)
    f = 0
    f1 = 32
    worstindex = 0
    o1 = offspr()
    for j in range(P):
        if population[j].fitness > f:
            bestindex = j
            f = population[j].fitness
            o1.gene = population[j].gene
            o1.fitness = population[j].fitness
    print("highest fitness = ", f)
    print("")
    for j in range(P):
        mutatedOffspring[j].fitness = 0
        population[j] = mutatedOffspring[j]
    for j in range(P):
        if population[j].fitness < f1:
            worstindex = j
    for j in range(P):
        if j == worstindex:
            population[worstindex] = o1
            population[worstindex].fitness = 0
